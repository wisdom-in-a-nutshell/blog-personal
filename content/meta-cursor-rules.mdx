---
title: 'Writing Cursor Rules with a Meta Cursor Rule'
publishedAt: '2025-04-10'
summary: 'AI forgets things between chats. Cursor Rules fix this. Learn why you need them and a trick to make writing them easy.'
tags: 'AI, Productivity, Cursor, Development, Systems'
---

I spend most of my coding time in Cursor. It's a fantastic tool for LLM assisted coding.

But coding with LLMs has a specific quirk: they possess strong **contextual memory** but lack **episodic memory**.

In simpler words, they recall information within a single conversation but forget everything once a new chat session begins. No memory of past interactions.

Think of it like working with a brilliant assistant who has amnesia. Every day, you repeat the same instructions:

- "Remember, we use camelCase here."
- "Our shared utilities go in the `lib` folder with this specific structure."
- "This is how the backend API expects requests."

If you use Cursor often, this should sound familiar. You constantly nudge the AI back toward your project's standards and personal preferences.

If you're already nodding in agreement and just want the meta cursor rule template, jump straight to [How to Create Rules Without the Friction](#how-to-create-rules-without-the-friction).

For everyone else, I'll explain why this is necessary, how we solve it with cursor rules, and how to create them efficiently using a meta-rule approach.

## Why, How, Then What

My approach is straightforward: understand _why_ a problem exists and _how_ a solution works. The _what_ (implementation) becomes much clearer afterward. You'll likely create even better solutions than I suggest.

## Why You Need Systems for AI

When working with teams of smart people, you build systems. Style guides, process documents, checklists. These ensure consistent, effective work with a unified aesthetic.

Now we work with intelligent LLMs instead. These LLMs are powerful, but they start fresh every time you chat. They have no memory of your preferences or how you structure your projects.

It's like hiring a new freelancer for every conversation. You explain everything from scratch repeatedly.

For quick scripts, this might not matter much. For serious applications built over time and that grows over weeks and months, you waste a lot of valuable time repeating:

- Coding conventions
- Folder structures
- Architectural patterns
- API interfaces
- Your preferred style

You need a way to instantly bring the AI up to speed.

Without a system to give the AI long-term preferences, you'll keep wasting time on repetitive explanations. Fortunately, Cursor provides a built-in solution.

## What Are Cursor Rules?

Cursor Rules are permanent instruction documents for the AI within your projects.

For each git repository, you create rule files that tell the LLM how to work with your specific codebase. Different repos have different rules, and each repo typically has multiple rules addressing various aspects of your project.

These rules solve the AI's memory gap. They act as a knowledge base, teaching the AI your project's patterns and preferences. When Cursor sees a file matching a rule's pattern, it loads that knowledge automatically. This creates consistency every time you chat with the AI.

## Creating Rules Without the Friction

The concept sounds simple: read the documentation and write some `.mdc` files.

But let's be honest. Many developers understand the benefits but hesitate because creating rules feels like extra work. It adds friction.

Here's a practical solution: **Use AI to write the rules for itself.**

How? By creating a **meta-cursor rule**.

This means creating _one_ rule that serves as a template for writing _all other_ rules. It defines the structure and content all your rules should follow.

Once you have this meta-rule, the process becomes simple:

1. Notice a pattern you want to codify
2. Open the Cursor chat
3. Point the AI to your meta-rule (e.g., "Using the `cursor-rule-creation.mdc` guide...")
4. Ask it to write a new rule based on your conversation (e.g., "write a rule for our component structure based on this chat")

The AI uses your template to generate a well-structured draft. Save it, and you're done. This drastically reduces the effort needed to build your rule library.

## Example Meta-Cursor Rule

Here's the comprehensive meta-rule guide itself, which you can place in `.cursor/rules/writing-cursor-rules.mdc` (or similar) to help you generate consistent project rules:

<VerbatimCode
  code={`\n# Creating Effective Cursor Project Rules\n\nThis meta-rule provides comprehensive guidance on creating effective Cursor Project Rules. These are \`.mdc\` files stored in your project\'s \`.cursor/rules\` directory that help the AI understand your specific codebase, conventions, and preferences. Following these guidelines will help you create rules that are easily understood by both humans and the AI, leading to more consistent and helpful AI interactions.\n\n## What are Cursor Project Rules?\n\nProject Rules are the recommended way to provide persistent, project-specific instructions to Cursor\'s AI. They live alongside your code (in \`.cursor/rules/\`) and are automatically activated when files matching their defined patterns (\`glob\`) are referenced in chat or other AI features.\n\nThink of them as a structured knowledge base for your project, teaching the AI:\n\n*   Coding conventions and style guides\n*   Architectural patterns\n*   API usage and interfaces\n*   Domain-specific knowledge\n*   Your personal or team preferences\n\n## Rule File Structure\n\nWhile flexible, a well-structured rule file improves clarity for both humans and the AI. Consider including the following components:\n\n### 1. YAML Frontmatter (Crucial)\n\n**Placement:** The YAML frontmatter block (\`--- ... ---\`) **must** be the absolute first content in the file. Any leading spaces, lines, or characters can prevent the rule from loading correctly.\n\n\`\`\`yaml\n---\ntitle: Brief Title of the Rule (e.g., React Component Guidelines)\ndescription: Guidelines for [what this rule covers and its purpose, e.g., structuring functional React components]\nglob: \"[pattern/to/match/files/**/*.{ext}]\" # See examples below\nalwaysApply: false # Optional: Set to true to always include this rule\n---\n\`\`\`\n\n*   **\`title\`**: A clear, descriptive title (5-7 words recommended).\n*   **\`description\`**: A concise, semantic description. Start with phrases like \"Guidelines for...\" or \"Instructions on...\" This likely helps Cursor automatically select the most relevant rule when multiple match.\n*   **\`glob\`**: File pattern(s) that trigger this rule\'s automatic activation. Be specific.\n    *   Examples:\n        *   \`src/components/**/*.{tsx,jsx}\` (React components)\n        *   \`src/server/api/**/*.ts\` (Server API routes)\n        *   \`*.{json,yaml,yml}\` (Configuration files)\n        *   \`src/utils/!(test).ts\` (Utility files, excluding tests)\n        *   \`{package.json,pnpm-lock.yaml}\` (Specific root files)\n*   **\`alwaysApply\`** (Optional, defaults to \`false\`): If \`true\`, the rule is included in context regardless of the files being referenced.\n\n### 2. Content Sections (Recommended Structure)\n\nOrganize the rule\'s content logically. Using markdown headings (\`##\`, \`###\`) is recommended.\n\n#### Introduction / Problem\n\n*   Briefly explain *what* problem this rule solves or *what* pattern it defines.\n*   Explain *why* this pattern/convention is important for this project.\n*   Mention *when* this rule is typically relevant.\n\n#### Pattern Description\n\n*   Clearly document the recommended pattern(s) or conventions.\n*   Use text explanations combined with clear code examples (using language-specific fenced code blocks).\n*   Highlight key components, functions, or concepts involved.\n*   If applicable, link to other relevant rules: \`[See API Conventions](mdc:api-conventions.mdc)\`\n\n#### Implementation Steps (If Applicable)\n\n*   Provide a clear, step-by-step guide if the rule describes a process.\n*   Use ordered lists.\n*   Identify decision points or variations.\n\n#### Real-World Examples (Highly Recommended)\n\n*   Link to *actual code* in the current repository using relative paths: \`[Example Button](mdc:../src/components/ui/Button.tsx)\`.\n*   Briefly explain *why* the linked code is a good example of the rule.\n*   Keep examples focused on the rule being described.\n\n#### Common Pitfalls / Anti-Patterns\n\n*   List common mistakes or deviations related to this rule.\n*   Explain how to recognize these issues.\n*   Suggest how to fix or avoid them.\n\n**Note:** Adapt this structure based on the rule\'s complexity. Simpler rules might only need frontmatter and a brief description or a few key points.\n\n## Advanced Features\n\n### File References (\`@file\`)\n\nInclude critical context files directly within your rule using the \`@file\` directive. Place these *after* the frontmatter but ideally *before* the main content.\n\n\`\`\`markdown\n@file ../tsconfig.json\n@file ../package.json\n@file ./docs/ARCHITECTURE.md\n\`\`\`\n\n*   Use relative paths from the rule file\'s location (\`.cursor/rules/\`).\n*   These files will be added to the context *whenever this rule is activated*, providing consistent background information to the AI.\n*   Use sparingly for essential files (configs, core types, architectural overviews) to avoid excessive context.\n\n### Code Blocks\n\nAlways use fenced code blocks with language specifiers for correct rendering and potential syntax highlighting by the AI:\n\n\`\`\`\`markdown\n\`\`\`typescript\nfunction greet(name: string): string {\n  // Correctly formatted TypeScript\n  return \`Hello, \${name}!\`;\n}\n\`\`\`\n\`\`\`\`\n\n## Rule Activation and Interaction\n\n*   **Automatic Activation:** Rules are primarily activated automatically when files matching their \`glob\` pattern are included in the context (e.g., opened file, @-referenced files, files included in \`@codebase\` search results).\n*   **Semantic Selection:** The \`description\` field likely helps Cursor choose the *most relevant* rule if multiple rules match the same file via their \`glob\` patterns.\n*   **Manual Activation:** You can explicitly include specific rules in a chat prompt using the \`@Cursor Rules\` symbol (e.g., \`@Cursor Rules(react-component-guide.mdc)\`).\n*   **Specificity:** More specific \`glob\` patterns are generally preferred to avoid unintended rule overlaps. If rules overlap, the exact selection logic isn\'t documented, but clearer descriptions and more specific globs likely lead to better results.\n*   **Modularity:** Break down complex domains (like your entire backend) into smaller, more focused rules (e.g., \`api-routing.mdc\`, \`database-models.mdc\`, \`auth-middleware.mdc\`) rather than creating one monolithic rule.\n\n## Best Practices\n\n*   **Start Simple, Iterate:** Don\'t aim for perfection immediately. Start with basic rules for core conventions and add/refine them over time as you observe the AI\'s behavior and identify gaps.\n*   **Be Specific but Flexible:** Provide clear, actionable guidance with concrete examples. Use recommending language (\"prefer\", \"consider\", \"typically\") rather than overly rigid commands (\"must\", \"always\") unless a strict convention is required. Explain the *why* behind rules.\n*   **Focus on Patterns:** Rules should define repeatable patterns, conventions, or project knowledge, not fix one-off bugs.\n*   **Keep Rules Updated:** Regularly review rules. Update them when conventions change or code evolves. *Delete* rules that become obsolete or if the AI consistently follows the pattern without the rule.\n*   **Trust the LLM (to an extent):** While rules provide guidance, allow the LLM some flexibility. It can often infer patterns from the existing codebase, especially as it grows.\n*   **Troubleshooting:** If rules aren\'t activating as expected, double-check:\n    *   The YAML frontmatter is the *absolute first* content in the file.\n    *   The \`glob\` pattern correctly matches the intended files.\n    *   File paths in \`@file\` directives are correct.\n    *   The \`.mdc\` file encoding is standard (UTF-8). \n\n## Team Collaboration\n\n*   **Version Control:** Commit the \`.cursor/rules\` directory to your repository so rules are shared and versioned alongside your code.\n*   **Conventions:** Establish team conventions for naming, structuring, and updating rules.\n*   **Review Process:** Consider code reviews for changes to important rules.\n*   **Onboarding:** Use rules as living documentation to help onboard new team members to project standards.\n*   **Shared vs. Personal:** If needed, establish naming conventions (e.g., \`_personal-*.mdc\`) and potentially use \`.gitignore\` within \`.cursor/rules\` to separate team-wide rules from personal experimental ones.\n\n## Full Rule Example\n\n\`\`\`markdown\n---\ntitle: React Functional Component Structure\ndescription: Guidelines for structuring functional React components using TypeScript, including prop definitions, state management, and hook usage.\nglob: \"src/components/**/*.tsx\"\nalwaysApply: false\n---\n\n@file ../../tsconfig.json\n@file ../../tailwind.config.js\n\n# React Functional Component Structure\n\n## Introduction\n\nThis rule defines the standard structure for functional React components in this project to ensure consistency, readability, and maintainability. We use TypeScript for type safety and prefer hooks for state and side effects.\n\n## Pattern Description\n\nComponents should generally follow this order:\n\n1.  \`\'use client\'\` directive (if needed)\n2.  Imports (React, libs, internal, types, styles)\n3.  Props interface definition (\`ComponentNameProps\`)\n4.  Component function definition (\`function ComponentName(...)\`)\n5.  State hooks (\`useState\`)\n6.  Other hooks (\`useMemo\`, \`useCallback\`, \`useEffect\`, custom hooks)\n7.  Helper functions (defined outside or memoized inside)\n8.  \`useEffect\` blocks\n9.  Return statement (JSX)\n\n\`\`\`typescript\n\'use client\' // Only if browser APIs or hooks like useState/useEffect are needed\n\nimport React, { useState, useEffect, useCallback } from \'react\';\nimport { cn } from \'@/lib/utils\'; // Example internal utility\nimport { type VariantProps, cva } from \'class-variance-authority\';\n\n// Define props interface\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {\n  isLoading?: boolean;\n}\n\n// Define component\nfunction Button({ className, variant, size, isLoading, children, ...props }: ButtonProps): React.ReactElement {\n  // State hooks\n  const [isMounted, setIsMounted] = useState(false);\n\n  // Other hooks\n  const handleClick = useCallback((event: React.MouseEvent<HTMLButtonElement>) => {\n    if (isLoading) {\n      event.preventDefault();\n      return;\n    }\n    props.onClick?.(event);\n  }, [isLoading, props.onClick]);\n\n  // Effects\n  useEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  // Conditional rendering logic can go here\n\n  // Return JSX\n  return (\n    <button\n      className={cn(buttonVariants({ variant, size, className }))}\n      disabled={isLoading}\n      onClick={handleClick}\n      {...props}\n    >\n      {isLoading ? \'Loading...\' : children}\n    </button>\n  );\n}\n\n// Example variant definition (could be in the same file or imported)\nconst buttonVariants = cva(\n  \'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background\',\n  {\n    variants: {\n      variant: {\n        default: \'bg-primary text-primary-foreground hover:bg-primary/90\',\n        // ... other variants\n      },\n      size: {\n        default: \'h-10 py-2 px-4\',\n        // ... other sizes\n      },\n    },\n    defaultVariants: {\n      variant: \'default\',\n      size: \'default\',\n    },\n  }\n);\n\nexport { Button, buttonVariants }; // Prefer named exports\n\`\`\`\n\n## Implementation Steps\n\n1.  Define a clear \`interface\` for props.\n2.  Use standard React hooks for state and side effects.\n3.  Keep components focused on a single responsibility.\n4.  Use named exports for components.\n\n## Real-World Examples\n\n*   [Standard Button Component](mdc:../src/components/ui/button.tsx)\n*   [Complex Card Component](mdc:../src/components/ui/card.tsx)\n\n## Common Pitfalls\n\n*   Forgetting \`\'use client\'\` when using hooks like \`useState\` or \`useEffect\`.\n*   Defining helper functions directly inside the component body without \`useCallback\` (can cause unnecessary re-renders).\n*   Overly complex components; consider breaking them down.\n*   Not using TypeScript for props or state.\n\n\`\`\`\n\n## Minimal Rule Template\n\nUse this as a quick starting point for new rules:\n\n\`\`\`markdown\n---\ntitle: [Rule Name]\ndescription: Guidelines for [purpose]\nglob: \"[pattern]\"\nalwaysApply: false\n---\n\n# [Rule Name]\n\n## Introduction / Problem\n\n[Why this rule exists and what problem it solves.]\n\n## Pattern Description\n\n[Explain the pattern with code examples.]\n\n## Real-World Examples\n\n*   [Link to code](mdc:../path/to/example.ts)\n\n## Common Pitfalls\n\n*   [Common mistake 1]\n*   [Common mistake 2]\n\n\`\`\`\n`}
/>

## Building Systems Pays Off

Using a meta-rule like this one helps you build systems for your AI interactions. You teach the AI how to create its own documentation consistently.

This creates a positive feedback loop, boosting consistency in your projects and saving you significant time. The small upfront investment in defining a good meta-rule pays off quickly as you spend less time repeating instructions and more time building.

What systems are you building to work more effectively with AI? Let me know.

```

```
