---
title: 'Writing Cursor Rules with a Meta Cursor Rule'
publishedAt: '2025-04-10'
summary: 'AI forgets things between chats. Cursor Rules fix this. Learn why you need them and a trick to make writing them easy.'
tags: 'AI, Productivity, Cursor, Development, Systems'
---

I spend most of my coding time in Cursor. It's a fantastic tool for LLM assisted coding.

But coding with LLMs has a specific quirk: they possess strong **contextual memory** but lack **episodic memory**.

In simpler words, they recall information within a single conversation but forget everything once a new chat session begins. No memory of past interactions.

Think of it like working with a brilliant assistant who has amnesia. Every day, you repeat the same instructions:

- "Remember, we use camelCase here."
- "Our shared utilities go in the `lib` folder with this specific structure."
- "This is how the backend API expects requests."

If you use Cursor often, this should sound familiar. You constantly nudge the AI back toward your project's standards and personal preferences.

If you're already nodding in agreement and just want the meta cursor rule template, jump straight to [How to Create Rules Without the Friction](#how-to-create-rules-without-the-friction).

For everyone else, I'll explain why this is necessary, how we solve it with cursor rules, and how to create them efficiently using a meta-rule approach.

## Why, How, Then What

My approach is straightforward: understand _why_ a problem exists and _how_ a solution works. The _what_ (implementation) becomes much clearer afterward. You'll likely create even better solutions than I suggest.

## Why You Need Systems for AI

When working with teams of smart people, you build systems. Style guides, process documents, checklists. These ensure consistent, effective work with a unified aesthetic.

Now we work with intelligent LLMs instead. These LLMs are powerful, but they start fresh every time you chat. They have no memory of your preferences or how you structure your projects.

It's like hiring a new freelancer for every conversation. You explain everything from scratch repeatedly.

For quick scripts, this might not matter much. For serious applications built over time and that grows over weeks and months, you waste  a lot of valuable time repeating:

- Coding conventions
- Folder structures
- Architectural patterns
- API interfaces
- Your preferred style

You need a way to instantly bring the AI up to speed.

Without a system to give the AI long-term preferences, you'll keep wasting time on repetitive explanations. Fortunately, Cursor provides a built-in solution.

## What Are Cursor Rules?

Cursor Rules are permanent instruction documents for the AI within your projects.

For each git repository, you create rule files that tell the LLM how to work with your specific codebase. Different repos have different rules, and each repo typically has multiple rules addressing various aspects of your project.

These rules solve the AI's memory gap. They act as a knowledge base, teaching the AI your project's patterns and preferences. When Cursor sees a file matching a rule's pattern, it loads that knowledge automatically. This creates consistency every time you chat with the AI.

## Creating Rules Without the Friction

The concept sounds simple: read the documentation and write some `.mdc` files.

But let's be honest. Many developers understand the benefits but hesitate because creating rules feels like extra work. It adds friction.

Here's a practical solution: **Use AI to write the rules for itself.**

How? By creating a **meta-cursor rule**.

This means creating _one_ rule that serves as a template for writing _all other_ rules. It defines the structure and content all your rules should follow.

Once you have this meta-rule, the process becomes simple:

1. Notice a pattern you want to codify
2. Open the Cursor chat
3. Point the AI to your meta-rule (e.g., "Using the `cursor-rule-creation.mdc` guide...")
4. Ask it to write a new rule based on your conversation (e.g., "write a rule for our component structure based on this chat")

The AI uses your template to generate a well-structured draft. Save it, and you're done. This drastically reduces the effort needed to build your rule library.

## Example Meta-Cursor Rule

Here's an example of a meta-cursor rule you can use to create new cursor rules.

<VerbatimCode
  code={`\n---\ndescription: This rule provides guidance on how to create effective Cursor rules that help developers understand and follow codebase patterns.\nglobs:\nalwaysApply: false\n---\n\n\n## Rule Location and Organization\n\n### Directory Structure\nAll cursor rules MUST be stored in the \`.cursor/rules\` directory:\n\n\`\`\`\n\n.cursor/\n└── rules/\n    ├── api-implementation.mdc\n    ├── server-startup-monitoring.mdc\n    ├── frontend-implementation-guide.mdc\n    └── cursor-rule-creation.mdc\n\n### File Naming\n- Use kebab-case for file names\n- Always use the \`.mdc\` extension\n- Names should be descriptive and indicate the rule\'s purpose\n\n# Writing Effective Cursor Rules\n\nThis meta-rule provides guidance on creating cursor rules that help document code patterns, architecture decisions, and best practices for your codebase.\n\n## What is a Cursor Rule?\n\nCursor rules are documentation files that Cursor AI can access to understand your project\'s specific patterns and requirements. They serve as knowledge bases that help maintain consistency across your codebase.\n\n## Rule Structure\n\nA well-structured cursor rule should include the following elements:\n\n### 1. YAML Frontmatter\n\n\`\`\`yaml\n---\ntitle: Brief Title of the Rule\ndescription: Guidelines for what this rule covers and its purpose in a standardized format\nglob: \"pattern/to/match/relevant/files/**/*.{ext}\"\nalwaysApply: true\n---\n\`\`\`\n\n- **title**: A clear, descriptive title (5-7 words)\n- **description**: A concise description starting with \"Guidelines for...\" that explains the rule\'s purpose\n- **glob**: File pattern(s) that should trigger this rule\n- **alwaysApply**: Set to true to have this rule applied automatically when relevant files are opened\n\n### 2. Introduction Section\n\nStart with a brief overview that explains:\n- What problem this rule addresses\n- Why following this pattern is important\n- When developers should apply this pattern\n\n### 3. Pattern Description\n\nClearly document the recommended pattern(s):\n- Explain the structure using both text and code examples\n- Highlight key components and their relationships\n- Include real file references from your codebase when possible\n- Use diagrams or structured lists to illustrate complex relationships\n\n### 4. Implementation Steps\n\nProvide a step-by-step guide for implementing the pattern:\n- Ordered list of actions to take\n- Decision points clearly identified\n- Prerequisites or dependencies mentioned\n\n### 5. Real-World Examples\n\nInclude examples from your actual codebase:\n- Link to real files (using relative paths)\n- Highlight the most important parts of the examples\n- Explain why these examples demonstrate best practices\n- Consider \"before and after\" examples for clarity\n\n### 6. Common Pitfalls\n\nDocument known issues or anti-patterns:\n- Problems that commonly arise\n- How to recognize them\n- How to fix or avoid them\n\n## Best Practices for Writing Rules\n\n### Be Specific and Actionable\n\n✅ DO:\n- Provide concrete examples\n- Link to actual files in the codebase\n- Give specific step-by-step instructions\n\n❌ DON\'T:\n- Use vague language like \"appropriately\" or \"properly\"\n- Assume knowledge without providing references\n- Include personal opinions without justification\n\n### Focus on Patterns, Not Individual Issues\n\nRules should document patterns that apply across multiple files or components, not fix individual bugs or issues.\n\n### Keep Rules Updated\n\nAs your codebase evolves, keep your rules updated:\n- Review rules regularly when patterns change\n- Remove outdated rules\n- Update examples to reflect current code\n\n### Use Clear, Consistent Formatting\n\n- Use markdown headings consistently (H1 for title, H2 for major sections, H3 for subsections)\n- Format code blocks with appropriate language tags\n- Use bullet points and numbered lists for clarity\n- Bold or italicize important points for emphasis\n\n## Example Rule Structure\n\nBelow is a simplified template for a cursor rule:\n\n\`\`\`markdown\n---\ntitle: Component Styling Pattern\ndescription: Guidelines for styling React components using CSS Modules for consistent appearance\nglob: \"**/*.{tsx,jsx,css}\"\nalwaysApply: true\n---\n\n# Component Styling Pattern\n\nThis rule documents our approach to styling React components using CSS Modules.\n\n## Overview\n\nWe use CSS Modules to scope styles to specific components, preventing style leakage and naming conflicts.\n\n## Directory Structure\n\nComponents with styles should follow this structure:\n\n\`\`\`\ncomponents/\n└── Button/\n    ├── Button.tsx\n    ├── Button.module.css\n    └── index.ts\n\`\`\`\n\n## Implementation Steps\n\n1. Create a component directory with the component name\n2. Create the component file (ComponentName.tsx)\n3. Create a CSS module file with the same name (ComponentName.module.css)\n4. Create an index.ts file that exports the component\n\n## Real-World Examples\n\nSee our Button component implementation:\n- [components/Button/Button.tsx](mdc:../src/components/Button/Button.tsx)\n- [components/Button/Button.module.css](mdc:../src/components/Button/Button.module.css)\n\n## Common Pitfalls\n\n- Don\'t mix global styles with module styles\n- Avoid deeply nested selectors\n- Don\'t use !important in module styles\n\`\`\`\n\n## Real Example from Your Codebase\n\nThe API Implementation rule we created is a good example of a well-structured rule:\n\n- It has clear YAML frontmatter with title, description, and glob pattern\n- The overview explains the job-based architecture and its importance\n- It documents multiple patterns with clear explanations\n- It includes real-world examples from your codebase\n- It lists common pitfalls to avoid\n- It has a step-by-step implementation guide\n\nBy following these guidelines, you\'ll create cursor rules that effectively document your codebase patterns and help all developers maintain consistency.\n`}
/>

```

```
