---
title: 'Writing Cursor Rules with a (Meta) Cursor Rule'
publishedAt: '2025-04-10'
summary: 'AI forgets things between chats. Cursor Rules fix this. Learn why you need them and a trick to make writing them easy.'
tags: 'AI, Productivity, Cursor, Development, Systems'
---

I spend most of my coding time in Cursor. It's a fantastic tool for LLM assisted coding.

But coding with LLMs has a specific quirk: they possess strong **contextual memory** but lack **episodic memory**.

Or in simpler words, they recall and use information from within a single conversation (the context) but forget everything once a new chat session begins (no memory of past conversations).

Think of it like working with a brilliant assistant who has amnesia. Every single day, you have to explain the basics again:

- "Remember, we use camelCase here."
- "Our shared utilities go in the `lib` folder with this specific folder structure."
- "This is how the backend API expects requests."

If you use Cursor often, this should sound very familiar. You nudge the AI back towards your project's standards or your personal preferences again, again and again.

If you already are nodding your head in agreement with what is being said here and the title of this blog post already make senses to you and you are just here for the meta cursor rules that you want plug, feel free to jump straight to the section on [How to Create Rules Without the Friction](#how-to-create-rules-without-the-friction).

For everyone else, I will try to explain a little bit why this is necessary, how we are going to solve this (cursor rules) and then how to actually create them without the friction (a meta cursor rule to create other cursor rules).

## My Approach: Why, How, Then What

When I write these posts... my style and philosophy is usually simple: If I can articulate _why_ a problem exists and _how_ a solution is supsposed to work to clearly. The the _what_ (the specific implementation) becomes obvious.

Very likely you will even devise better solutions than I could suggest.

So with that as motivation, let's dive into the _why_ and _how_ of cursor rules.

## Why You Need Systems for AI

When working with team of intelligent people and you want them to work consistently and effectively, you build systems.

Style guides, process documents, checklists. These ensure everyone works consistently and effectively and there is a style and aesthetic to the work that everybody can buy into.

Now luckily indie devs liek us, we will live in teh age of leverage.... we all have access to such  vitual people.. these are the LLMs you invoke you open a chat indown in teh curors.

They are all very capabile. but every time you start a new chat, they dont have any memory of the previous conversation or how you liek to do things.

The brst example.. its like hiring a freelance developer. You have to explain the whole thing from scratch every time.

They need systems too, especially because of that amnesia problem.

For quick, throw-away scripts, consistency might not matter much. But for real applications built over time, it's crucial. You waste valuable time re-explaining:

- Coding conventions
- Folder structures
- Architectural patterns
- API interfaces
- Your preferred style

You need a way to instantly bring the AI up to speed**.**

Without a system to give the AI this long-term memory, you'll keep wasting time on repetitive explanations. Fortunately, Cursor provides a built-in way to create exactly these kinds of systems.

So how to solve this?

Luckliy cursor has a built in way to create exactly these kinds of systems.

There are many sorts of systee... one is cursor rules..

## What Are Cursor Rules? The System for Cursor AI

They are essentially permanent instruction documents for the AI within your Cursor projects.

Or more typically, for each of your git repos you have a bunch of cursor rule file that are tell the LLM how they are suposed to work in this specici reposity. Differnete repos will have different rules.
And typically each repsoity will have a collection of rules that addres diffenet.

Think of them as the solution to the AI's episodic memory gap. They act as a knowledge base, teaching the AI your project's specific patterns and preferences. When Cursor sees a file matching a rule's pattern, it loads that knowledge. This creates consistency every time you chat with the AI in that project.

Having these rules ensures the AI consistently follows your project's standards. We've covered the _why_ (avoiding amnesia) and the _how_ (Cursor Rules). But the _what_ – the process of actually writing these rules – often presents its own challenge. Let's tackle that next.

## What
Okay, so rules are important. The "How" seems simple: read the Cursor documentation and write some `.mdc` files.

But let's be honest. Many developers _understand_ the benefits but hesitate because creating rules feels like extra work. It adds friction.

Here's a practical tip to overcome that friction: **Use AI to write the rules for itself.**

waht? By creating a **meta-cursor rule**.

This is just a fancy way of saying you create _one_ rule that acts as a template or guide for writing _all other_ rules. It codifies the structure and content you want your rules to have.

Once you have this meta-rule, the process becomes easy:

1. Notice a pattern you want to codify.
2. Open the Cursor chat. Tell the AI eveyrthign you want to tell....
3. Point the AI to your meta-rule (e.g., "Using the `cursor-rule-creation.mdc` guide...").
4. Ask it to write a new rule based on the pattern or even a recent chat conversation ("...write a rule for our component structure based on this chat.").

The AI uses your meta-rule template to generate a well-structured draft. Save it, and you're done. This drastically lowers the effort needed to build your rule library.

## Example Meta-Cursor Rule

Here's an example of a meta-cursor rule that you can use to create new cursor rules.

<VerbatimCode
  code={`\n---\ndescription: This rule provides guidance on how to create effective Cursor rules that help developers understand and follow codebase patterns.\nglobs:\nalwaysApply: false\n---\n\n\n## Rule Location and Organization\n\n### Directory Structure\nAll cursor rules MUST be stored in the \`.cursor/rules\` directory:\n\n\`\`\`\n\n.cursor/\n└── rules/\n    ├── api-implementation.mdc\n    ├── server-startup-monitoring.mdc\n    ├── frontend-implementation-guide.mdc\n    └── cursor-rule-creation.mdc\n\n### File Naming\n- Use kebab-case for file names\n- Always use the \`.mdc\` extension\n- Names should be descriptive and indicate the rule\'s purpose\n\n# Writing Effective Cursor Rules\n\nThis meta-rule provides guidance on creating cursor rules that help document code patterns, architecture decisions, and best practices for your codebase.\n\n## What is a Cursor Rule?\n\nCursor rules are documentation files that Cursor AI can access to understand your project\'s specific patterns and requirements. They serve as knowledge bases that help maintain consistency across your codebase.\n\n## Rule Structure\n\nA well-structured cursor rule should include the following elements:\n\n### 1. YAML Frontmatter\n\n\`\`\`yaml\n---\ntitle: Brief Title of the Rule\ndescription: Guidelines for what this rule covers and its purpose in a standardized format\nglob: \"pattern/to/match/relevant/files/**/*.{ext}\"\nalwaysApply: true\n---\n\`\`\`\n\n- **title**: A clear, descriptive title (5-7 words)\n- **description**: A concise description starting with \"Guidelines for...\" that explains the rule\'s purpose\n- **glob**: File pattern(s) that should trigger this rule\n- **alwaysApply**: Set to true to have this rule applied automatically when relevant files are opened\n\n### 2. Introduction Section\n\nStart with a brief overview that explains:\n- What problem this rule addresses\n- Why following this pattern is important\n- When developers should apply this pattern\n\n### 3. Pattern Description\n\nClearly document the recommended pattern(s):\n- Explain the structure using both text and code examples\n- Highlight key components and their relationships\n- Include real file references from your codebase when possible\n- Use diagrams or structured lists to illustrate complex relationships\n\n### 4. Implementation Steps\n\nProvide a step-by-step guide for implementing the pattern:\n- Ordered list of actions to take\n- Decision points clearly identified\n- Prerequisites or dependencies mentioned\n\n### 5. Real-World Examples\n\nInclude examples from your actual codebase:\n- Link to real files (using relative paths)\n- Highlight the most important parts of the examples\n- Explain why these examples demonstrate best practices\n- Consider \"before and after\" examples for clarity\n\n### 6. Common Pitfalls\n\nDocument known issues or anti-patterns:\n- Problems that commonly arise\n- How to recognize them\n- How to fix or avoid them\n\n## Best Practices for Writing Rules\n\n### Be Specific and Actionable\n\n✅ DO:\n- Provide concrete examples\n- Link to actual files in the codebase\n- Give specific step-by-step instructions\n\n❌ DON\'T:\n- Use vague language like \"appropriately\" or \"properly\"\n- Assume knowledge without providing references\n- Include personal opinions without justification\n\n### Focus on Patterns, Not Individual Issues\n\nRules should document patterns that apply across multiple files or components, not fix individual bugs or issues.\n\n### Keep Rules Updated\n\nAs your codebase evolves, keep your rules updated:\n- Review rules regularly when patterns change\n- Remove outdated rules\n- Update examples to reflect current code\n\n### Use Clear, Consistent Formatting\n\n- Use markdown headings consistently (H1 for title, H2 for major sections, H3 for subsections)\n- Format code blocks with appropriate language tags\n- Use bullet points and numbered lists for clarity\n- Bold or italicize important points for emphasis\n\n## Example Rule Structure\n\nBelow is a simplified template for a cursor rule:\n\n\`\`\`markdown\n---\ntitle: Component Styling Pattern\ndescription: Guidelines for styling React components using CSS Modules for consistent appearance\nglob: \"**/*.{tsx,jsx,css}\"\nalwaysApply: true\n---\n\n# Component Styling Pattern\n\nThis rule documents our approach to styling React components using CSS Modules.\n\n## Overview\n\nWe use CSS Modules to scope styles to specific components, preventing style leakage and naming conflicts.\n\n## Directory Structure\n\nComponents with styles should follow this structure:\n\n\`\`\`\ncomponents/\n└── Button/\n    ├── Button.tsx\n    ├── Button.module.css\n    └── index.ts\n\`\`\`\n\n## Implementation Steps\n\n1. Create a component directory with the component name\n2. Create the component file (ComponentName.tsx)\n3. Create a CSS module file with the same name (ComponentName.module.css)\n4. Create an index.ts file that exports the component\n\n## Real-World Examples\n\nSee our Button component implementation:\n- [components/Button/Button.tsx](mdc:../src/components/Button/Button.tsx)\n- [components/Button/Button.module.css](mdc:../src/components/Button/Button.module.css)\n\n## Common Pitfalls\n\n- Don\'t mix global styles with module styles\n- Avoid deeply nested selectors\n- Don\'t use !important in module styles\n\`\`\`\n\n## Real Example from Your Codebase\n\nThe API Implementation rule we created is a good example of a well-structured rule:\n\n- It has clear YAML frontmatter with title, description, and glob pattern\n- The overview explains the job-based architecture and its importance\n- It documents multiple patterns with clear explanations\n- It includes real-world examples from your codebase\n- It lists common pitfalls to avoid\n- It has a step-by-step implementation guide\n\nBy following these guidelines, you\'ll create cursor rules that effectively document your codebase patterns and help all developers maintain consistency.\n`}
/>

```

```
